{% block content %}
<div id="elwrap">
  <canvas id="elcanvas" width="256" height="256"></canvas>
</div>
<div id="eltemp" style="color:black;background:white;font:3em monospace;
position:fixed;z-index:100;top:0;left:0;opacity:0.2"> </div>
{% endblock %}

{% block additional_scripts %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.12.0/matter.min.js"></script>
<script>
console.clear();
const app = {
  buffer: { width: 0, height: 0 },
  engine: null,
  render: null, 
  bodies: [],
  vents: [],
  drawFnIndex: 0,
  ctx: null,
  baseSpeed: 0.001,
  drawFns: [drawLine] // custom draw functions
};

setup(app);
createBodies(app, 2, 4);
createVents(app);
registerEvents(app);
start(app);


function setup(app) {
  app.buffer.width = elcanvas.width;
  app.buffer.height = elcanvas.height;
  app.engine = Matter.Engine.create();
  app.engine.world.gravity.y = 0.0;
  app.engine.world.gravity.x = 0.1;
  app.ctx = elcanvas.getContext("2d");
  app.baseSpeed = 0.001;
}

function createBodies(app, yy, side) {
  const xx = app.buffer.width / side | 0;
  const bw = app.buffer.width;
  const bh = app.buffer.height;
  
  for (const y of Array(yy).keys()) {
    for (const x of Array(xx).keys()) {
      const body = Matter.Bodies.rectangle(
        side + x * side, 
        side + (bh - y * side)/2 + y * side,
        side, side
      );
      app.bodies.push(body);
    }
  }
  Matter.World.add(app.engine.world, app.bodies);
  
  // walls
  const WT = 1; // wall thickness
  Matter.World.add(app.engine.world, [
    Matter.Bodies.rectangle(bw/2, -WT/2, 1e5, WT, {isStatic:true}),
    Matter.Bodies.rectangle(bw/2, bh + WT/2, 1e5, WT, {isStatic:true})
  ]);
}

function createVents(app) {
  const speed = app.baseSpeed;
  const {width, height} = app.buffer;
  app.vents.push({ 
    position: Matter.Vector.create(width * 1/4, height),
    force: Matter.Vector.create(0, speed * -0.5),
  });
  app.vents.push({
    position: Matter.Vector.create(width * 3/4, 0),
    force: Matter.Vector.create(0, speed * 1.0),
  });
}

function registerEvents(app) {
  const {width, height} = app.buffer;
  const {Vector:V, Body:B, Events:E} = Matter;
  
  E.on(app.engine, "tick", e => {
    for (const body of app.bodies) {
      if (body.position.x > width) {
        B.setPosition(body, V.create(0, body.position.y));
        B.setVelocity(body, V.create(app.baseSpeed,0));
      }

      let force = V.create(0, 0);
      for (const vent of app.vents) {
        const dist = V.magnitude(V.sub(body.position, vent.position));
        force = V.add(force, V.mult(vent.force, 1/dist));
      }

      B.applyForce(body, body.position, force);
    }

    app.drawFns[app.drawFnIndex](app.ctx, app);
  });  
}

function start(app) {
  Matter.Engine.run(app.engine);
}

function drawLine(ctx, app) {
  const ls = 2; // scale 
  const lw = 1;
  ctx.globalCompositeOperation = `source-over`
  ctx.fillStyle = `rgba(255,255,255,0.2)`;
  ctx.fillRect(0,0,app.buffer.width, app.buffer.height);
  
  for (const body of app.bodies) {
    const {x:vx, y:vy} = body.velocity; // * LENGTH_SCALE);
    ctx.beginPath();
    ctx.moveTo(body.position.x, body.position.y);
    ctx.lineTo(body.position.x + vx*vx*ls, body.position.y + vy*vy*ls);
    ctx.lineWidth = lw;
    ctx.strokeStyle = 'rgba(0,0,0,0.02)';
    ctx.stroke();
  }
}
</script>
{% endblock %}